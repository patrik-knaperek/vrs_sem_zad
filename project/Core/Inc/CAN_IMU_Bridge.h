/** 
  ******************************************************************************
  * @file    CAN2020.h
  * @author  SGT Generated by tool
  * @version V0.1.0 (generator)
  * @date    20-December-2022
  * @brief   CAN protocol application/PROFILE layer for use in SGT formula student electric 2015
  ******************************************************************************
    Header contains all CAN bus message structures and defines of signals
    for STUBA Green Team formula 2015 created by Marek Laszlo and Marius Rak 
  ******************************************************************************
  Do not change document and messages structure!

  HOW TO RECEIVE:
  -do your init of CAN device in main.c
  -define used structures by uncommenting in CAN2015.h
  -use extern for CAN2015.h data structures in your main.c file
  -send messages using declared functions. Received structures are saved automatically in receive structures
  -work with data from structure :)

  HOW TO TRANSMIT:
  -fill structure of message you want to send
  -call correspondent transmit function which will fill the TX  message structure and transmit

  ******************************************************************************/
#ifndef CAN2020_H_
#define CAN2020_H_

//#define Tx_INT_control_data 1
#define Rx_INT_control_data 1
#define ID_INT_control_data 0x20
#define DLC_INT_control_data 5
/* INT_control_data
 * 
 *
 * ID 0x20
 * Message size DLC: 5 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * car_state        | A |  0 |  8 |  uint8_t | 
 * right_w_pump     | B |  8 |  1 |  uint8_t | 
 * left_w_pump	     | C |  9 |  1 |  uint8_t | 
 * brake_red        | D | 10 |  1 |  uint8_t | 
 * TSAS             | E | 11 |  1 |  uint8_t | 
 * killswitch_R     | F | 12 |  1 |  uint8_t | 
 * killswitch_L     | G | 13 |  1 |  uint8_t | 
 * brake_white      | H | 14 |  1 |  uint8_t | 
 * susp_RR          | I | 15 | 12 | uint16_t | 
 * susp_RL          | J | 27 | 12 | uint16_t | 
 * reserved         | K | 39 |  8 |  uint8_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|C|D|E|F|G|H|I|
// b |2|I|I|I|I|I|I|I|I|
// y |3|I|I|I|J|J|J|J|J|
// t |4|J|J|J|J|J|J|J|K|
// e |5|K|K|K|K|K|K|K| |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint8_t car_state;
    uint8_t right_w_pump;
    uint8_t left_w_pump	;
    uint8_t brake_red;
    uint8_t TSAS;
    uint8_t killswitch_R;
    uint8_t killswitch_L;
    uint8_t brake_white;
    uint16_t susp_RR;
    uint16_t susp_RL;
    uint8_t reserved;
} INT_control_data_TypeDef;

#ifdef Tx_INT_control_data
void Tx_INT_control_data_Data(CAN_HandleTypeDef* hcan, INT_control_data_TypeDef* INT_control_data_Data);
#endif

//#define Tx_ACU_control_status 1
#define Rx_ACU_control_status 1
#define ID_ACU_control_status 0x60
#define DLC_ACU_control_status 4
/* ACU_control_status
 * 
 *
 * ID 0x60
 * Message size DLC: 4 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * SHD_IN           | A |  0 |  1 |  uint8_t | 0:Napatie nepritomne 1:Napatie pritomne
 * SHD_OUT          | B |  1 |  1 |  uint8_t | 0:Napatie nepritomne 1:Napatie pritomne
 * TSMS             | C |  2 |  1 |  uint8_t | 0:Napatie nepritomne 1:Napatie pritomne
 * AIR_N            | D |  3 |  1 |  uint8_t | 0:Napatie nepritomne 1:Napatie pritomne
 * AIR_P            | E |  4 |  1 |  uint8_t | 0:Napatie nepritomne 1:Napatie pritomne
 * PRECH_60V        | F |  5 |  1 |  uint8_t | 0:prech rele OFF, a napatie menej ako 60V 1:prech rele ON alebo napatie viac ako 60V
 * IMD_OK           | G |  6 |  1 |  uint8_t | 0:chybovy stav 1:IMD OK - signal pre mosfet ON
 * BMS_OK           | H |  7 |  1 |  uint8_t | 0:chybovy stav 1:IMD OK - signal pre mosfet ON
 * SIGNAL_ERROR     | I |  8 |  1 |  uint8_t | 0:chyba v prudovej sonde 1:prudova sonda ok
 * SHD_RESET        | J |  9 |  1 |  uint8_t | 0:resetuje sa SHD chyba 1:normal stav bez resetu
 * SHD_EN           | K | 10 |  1 |  uint8_t | 0:SHD_vypnuty 1:SHD_moze byt
 * POLARITY         | L | 11 |  1 |  uint8_t | 0:prud tecie do boxu 1:prud tecie z boxu
 * FANS             | M | 12 |  1 |  uint8_t | 	0: ventilatory vypnute 1:ventilatory zapnute
 * IMD_RES          | N | 13 | 16 | uint16_t | IMD resistance in kOhm
 * IMD_ERROR        | O | 29 |  3 |  uint8_t | Error codes: 0 - all OK, 1 - Speed start, 2 - short circuit, 3 - undervoltage, 4 - device error, 5 - earth connection fault
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|B|C|D|E|F|G|H|
//   |1|I|J|K|L|M|N|N|N|
// b |2|N|N|N|N|N|N|N|N|
// y |3|N|N|N|N|N|O|O|O|
// t |4| | | | | | | | |
// e |5| | | | | | | | |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint8_t SHD_IN;
    uint8_t SHD_OUT;
    uint8_t TSMS;
    uint8_t AIR_N;
    uint8_t AIR_P;
    uint8_t PRECH_60V;
    uint8_t IMD_OK;
    uint8_t BMS_OK;
    uint8_t SIGNAL_ERROR;
    uint8_t SHD_RESET;
    uint8_t SHD_EN;
    uint8_t POLARITY;
    uint8_t FANS;
    uint16_t IMD_RES;
    uint8_t IMD_ERROR;
} ACU_control_status_TypeDef;

#ifdef Tx_ACU_control_status
void Tx_ACU_control_status_Data(CAN_HandleTypeDef* hcan, ACU_control_status_TypeDef* ACU_control_status_Data);
#endif

//#define Tx_ACU_TSBox_data 1
#define Rx_ACU_TSBox_data 1
#define ID_ACU_TSBox_data 0x70
#define DLC_ACU_TSBox_data 6
/* ACU_TSBox_data
 * 
 *
 * ID 0x70
 * Message size DLC: 6 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * power            | A |  0 | 16 |  int16_t | 
 * current          | B | 16 | 16 |  int16_t | 
 * voltage          | C | 32 | 16 |  int16_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2|B|B|B|B|B|B|B|B|
// y |3|B|B|B|B|B|B|B|B|
// t |4|C|C|C|C|C|C|C|C|
// e |5|C|C|C|C|C|C|C|C|
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    int16_t power;
    int16_t current;
    int16_t voltage;
} ACU_TSBox_data_TypeDef;

#ifdef Tx_ACU_TSBox_data
void Tx_ACU_TSBox_data_Data(CAN_HandleTypeDef* hcan, ACU_TSBox_data_TypeDef* ACU_TSBox_data_Data);
#endif

//#define Tx_AMS_acuseg_voltage 1
#define Rx_AMS_acuseg_voltage 1
#define ID_AMS_acuseg_voltage 0x90
#define DLC_AMS_acuseg_voltage 8
/* AMS_acuseg_voltage
 * 8/8
 *
 * ID 0x90
 * Message size DLC: 8 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * volt_ident       | A |  0 |  8 |  uint8_t | Identifier of sent voltages
 * voltage1         | B |  8 |  8 |  uint8_t | Cell voltage, (0-255x10+2000) mV
 * voltage2         | C | 16 |  8 |  uint8_t | Cell voltage, (0-255x10+2000) mV
 * voltage3         | D | 24 |  8 |  uint8_t | Cell voltage, (0-255x10+2000) mV
 * voltage4         | E | 32 |  8 |  uint8_t | Cell voltage, (0-255x10+2000) mV
 * voltage5         | F | 40 |  8 |  uint8_t | Cell voltage, (0-255x10+2000) mV
 * voltage6         | G | 48 |  8 |  uint8_t | Cell voltage, (0-255x10+2000) mV
 * voltage7         | H | 56 |  8 |  uint8_t | Cell voltage, (0-255x10+2000) mV
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|B|B|B|B|B|B|B|
// b |2|C|C|C|C|C|C|C|C|
// y |3|D|D|D|D|D|D|D|D|
// t |4|E|E|E|E|E|E|E|E|
// e |5|F|F|F|F|F|F|F|F|
//   |6|G|G|G|G|G|G|G|G|
//   |7|H|H|H|H|H|H|H|H|
typedef struct
{
    uint8_t volt_ident;
    uint8_t voltage1;
    uint8_t voltage2;
    uint8_t voltage3;
    uint8_t voltage4;
    uint8_t voltage5;
    uint8_t voltage6;
    uint8_t voltage7;
} AMS_acuseg_voltage_TypeDef;

#ifdef Tx_AMS_acuseg_voltage
void Tx_AMS_acuseg_voltage_Data(CAN_HandleTypeDef* hcan, AMS_acuseg_voltage_TypeDef* AMS_acuseg_voltage_Data);
#endif

//#define Tx_AMS_acuseg_temp 1
#define Rx_AMS_acuseg_temp 1
#define ID_AMS_acuseg_temp 0x100
#define DLC_AMS_acuseg_temp 8
/* AMS_acuseg_temp
 * 8/8
 *
 * ID 0x100
 * Message size DLC: 8 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * temp_ident       | A |  0 |  8 |  uint8_t | Identifier of sent temperatures	
 * temp1            | B |  8 |  8 |  uint8_t | Cell temperature, 0-255 degC	
 * temp2            | C | 16 |  8 |  uint8_t | Cell temperature, 0-255 degC	
 * temp3            | D | 24 |  8 |  uint8_t | Cell temperature, 0-255 degC	
 * temp4            | E | 32 |  8 |  uint8_t | Cell temperature, 0-255 degC	
 * temp5            | F | 40 |  8 |  uint8_t | Cell temperature, 0-255 degC	
 * temp6            | G | 48 |  8 |  uint8_t | Cell temperature, 0-255 degC	
 * temp7            | H | 56 |  8 |  uint8_t | Cell temperature, 0-255 degC	
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|B|B|B|B|B|B|B|
// b |2|C|C|C|C|C|C|C|C|
// y |3|D|D|D|D|D|D|D|D|
// t |4|E|E|E|E|E|E|E|E|
// e |5|F|F|F|F|F|F|F|F|
//   |6|G|G|G|G|G|G|G|G|
//   |7|H|H|H|H|H|H|H|H|
typedef struct
{
    uint8_t temp_ident;
    uint8_t temp1;
    uint8_t temp2;
    uint8_t temp3;
    uint8_t temp4;
    uint8_t temp5;
    uint8_t temp6;
    uint8_t temp7;
} AMS_acuseg_temp_TypeDef;

#ifdef Tx_AMS_acuseg_temp
void Tx_AMS_acuseg_temp_Data(CAN_HandleTypeDef* hcan, AMS_acuseg_temp_TypeDef* AMS_acuseg_temp_Data);
#endif

//#define Tx_FCU_pedal_data 1
#define Rx_FCU_pedal_data 1
#define ID_FCU_pedal_data 0x120
#define DLC_FCU_pedal_data 4
/* FCU_pedal_data
 * 
 *
 * ID 0x120
 * Message size DLC: 4 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * APPS1            | A |  0 |  8 |  uint8_t | 0-100%
 * APPS2            | B |  8 |  8 |  uint8_t | 0-100%
 * brake1           | C | 16 |  8 |  uint8_t | psi
 * brake2           | D | 24 |  8 |  uint8_t | psi
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|B|B|B|B|B|B|B|
// b |2|C|C|C|C|C|C|C|C|
// y |3|D|D|D|D|D|D|D|D|
// t |4| | | | | | | | |
// e |5| | | | | | | | |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint8_t APPS1;
    uint8_t APPS2;
    uint8_t brake1;
    uint8_t brake2;
} FCU_pedal_data_TypeDef;

#ifdef Tx_FCU_pedal_data
void Tx_FCU_pedal_data_Data(CAN_HandleTypeDef* hcan, FCU_pedal_data_TypeDef* FCU_pedal_data_Data);
#endif

//#define Tx_FCU_steercont_data 1
#define Rx_FCU_steercont_data 1
#define ID_FCU_steercont_data 0x130
#define DLC_FCU_steercont_data 2
/* FCU_steercont_data
 * 
 *
 * ID 0x130
 * Message size DLC: 2 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * steer            | A |  0 |  8 |   int8_t | -127 = L, 127 = R
 * brake_pos        | B |  8 |  8 |  uint8_t | 0 - 100%
 * RTD              | C | 16 |  1 |  uint8_t | 
 * BOTS             | D | 17 |  1 |  uint8_t | 
 * SHDB             | E | 18 |  1 |  uint8_t | 
 * INERTIA_SW       | F | 19 |  1 |  uint8_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|B|B|B|B|B|B|B|
// b |2|C|D|E|F| | | | |
// y |3| | | | | | | | |
// t |4| | | | | | | | |
// e |5| | | | | | | | |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    int8_t steer;
    uint8_t brake_pos;
    uint8_t RTD;
    uint8_t BOTS;
    uint8_t SHDB;
    uint8_t INERTIA_SW;
} FCU_steercont_data_TypeDef;

#ifdef Tx_FCU_steercont_data
void Tx_FCU_steercont_data_Data(CAN_HandleTypeDef* hcan, FCU_steercont_data_TypeDef* FCU_steercont_data_Data);
#endif

//#define Tx_DSH_shutdown_status 1
#define Rx_DSH_shutdown_status 1
#define ID_DSH_shutdown_status 0x200
#define DLC_DSH_shutdown_status 0
/* DSH_shutdown_status
 * 
 *
 * ID 0x200
 * Message size DLC: 0 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * RTD              | A |  0 |  1 |  uint8_t | 
 * SHDB             | B |  1 |  1 |  uint8_t | 
 * INERTIA_SW       | C |  2 |  1 |  uint8_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|B|C| | | | | |
//   |1| | | | | | | | |
// b |2| | | | | | | | |
// y |3| | | | | | | | |
// t |4| | | | | | | | |
// e |5| | | | | | | | |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint8_t RTD;
    uint8_t SHDB;
    uint8_t INERTIA_SW;
} DSH_shutdown_status_TypeDef;

#ifdef Tx_DSH_shutdown_status
void Tx_DSH_shutdown_status_Data(CAN_HandleTypeDef* hcan, DSH_shutdown_status_TypeDef* DSH_shutdown_status_Data);
#endif

//#define Tx_ACU_AMS_command 1
#define Rx_ACU_AMS_command 1
#define ID_ACU_AMS_command 0x220
#define DLC_ACU_AMS_command 3
/* ACU_AMS_command
 * 
 *
 * ID 0x220
 * Message size DLC: 3 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * meas_state       | A |  0 |  8 |  uint8_t | 
 * flags            | B |  8 | 16 | uint16_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|B|B|B|B|B|B|B|
// b |2|B|B|B|B|B|B|B|B|
// y |3| | | | | | | | |
// t |4| | | | | | | | |
// e |5| | | | | | | | |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint8_t meas_state;
    uint16_t flags;
} ACU_AMS_command_TypeDef;

#ifdef Tx_ACU_AMS_command
void Tx_ACU_AMS_command_Data(CAN_HandleTypeDef* hcan, ACU_AMS_command_TypeDef* ACU_AMS_command_Data);
#endif

//#define Tx_FCU_sensor_error 1
#define Rx_FCU_sensor_error 1
#define ID_FCU_sensor_error 0x225
#define DLC_FCU_sensor_error 5
/* FCU_sensor_error
 * 
 *
 * ID 0x225
 * Message size DLC: 5 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * error            | A |  0 |  8 |  uint8_t | 
 * dummy            | B |  8 | 32 | uint32_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|B|B|B|B|B|B|B|
// b |2|B|B|B|B|B|B|B|B|
// y |3|B|B|B|B|B|B|B|B|
// t |4|B|B|B|B|B|B|B|B|
// e |5| | | | | | | | |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint8_t error;
    uint32_t dummy;
} FCU_sensor_error_TypeDef;

#ifdef Tx_FCU_sensor_error
void Tx_FCU_sensor_error_Data(CAN_HandleTypeDef* hcan, FCU_sensor_error_TypeDef* FCU_sensor_error_Data);
#endif

//#define Tx_DSH_oil_temp 1
#define Rx_DSH_oil_temp 1
#define ID_DSH_oil_temp 0x230
#define DLC_DSH_oil_temp 8
/* DSH_oil_temp
 * 8/8
 *
 * ID 0x230
 * Message size DLC: 8 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * FL_temp          | A |  0 | 16 | uint16_t | 
 * FR_temp          | B | 16 | 16 | uint16_t | 
 * RL_temp          | C | 32 | 16 | uint16_t | 
 * RR_temp          | D | 48 | 16 | uint16_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2|B|B|B|B|B|B|B|B|
// y |3|B|B|B|B|B|B|B|B|
// t |4|C|C|C|C|C|C|C|C|
// e |5|C|C|C|C|C|C|C|C|
//   |6|D|D|D|D|D|D|D|D|
//   |7|D|D|D|D|D|D|D|D|
typedef struct
{
    uint16_t FL_temp;
    uint16_t FR_temp;
    uint16_t RL_temp;
    uint16_t RR_temp;
} DSH_oil_temp_TypeDef;

#ifdef Tx_DSH_oil_temp
void Tx_DSH_oil_temp_Data(CAN_HandleTypeDef* hcan, DSH_oil_temp_TypeDef* DSH_oil_temp_Data);
#endif

//#define Tx_DSH_suspension_sensors_raw 1
#define Rx_DSH_suspension_sensors_raw 1
#define ID_DSH_suspension_sensors_raw 0x250
#define DLC_DSH_suspension_sensors_raw 8
/* DSH_suspension_sensors_raw
 * 
 *
 * ID 0x250
 * Message size DLC: 8 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * FA               | A |  0 | 16 | uint16_t | 
 * FB               | B | 16 | 16 | uint16_t | 
 * RA               | C | 32 | 16 | uint16_t | 
 * RB               | D | 48 | 16 | uint16_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2|B|B|B|B|B|B|B|B|
// y |3|B|B|B|B|B|B|B|B|
// t |4|C|C|C|C|C|C|C|C|
// e |5|C|C|C|C|C|C|C|C|
//   |6|D|D|D|D|D|D|D|D|
//   |7|D|D|D|D|D|D|D|D|
typedef struct
{
    uint16_t FA;
    uint16_t FB;
    uint16_t RA;
    uint16_t RB;
} DSH_suspension_sensors_raw_TypeDef;

#ifdef Tx_DSH_suspension_sensors_raw
void Tx_DSH_suspension_sensors_raw_Data(CAN_HandleTypeDef* hcan, DSH_suspension_sensors_raw_TypeDef* DSH_suspension_sensors_raw_Data);
#endif

//#define Tx_INT_coolant_temp 1
#define Rx_INT_coolant_temp 1
#define ID_INT_coolant_temp 0x255
#define DLC_INT_coolant_temp 8
/* INT_coolant_temp
 * 
 *
 * ID 0x255
 * Message size DLC: 8 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * Temp_L1          | A |  0 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 * Temp_L2          | B |  8 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 * Temp_L3          | C | 16 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 * Temp_L4          | D | 24 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 * Temp_R1          | E | 32 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 * Temp_R2          | F | 40 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 * Temp_R3          | G | 48 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 * Temp_R4          | H | 56 |  8 |  uint8_t | Coolant temperature, 0-127 degC, 0.5deg/bit
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|B|B|B|B|B|B|B|B|
// b |2|C|C|C|C|C|C|C|C|
// y |3|D|D|D|D|D|D|D|D|
// t |4|E|E|E|E|E|E|E|E|
// e |5|F|F|F|F|F|F|F|F|
//   |6|G|G|G|G|G|G|G|G|
//   |7|H|H|H|H|H|H|H|H|
typedef struct
{
    uint8_t Temp_L1;
    uint8_t Temp_L2;
    uint8_t Temp_L3;
    uint8_t Temp_L4;
    uint8_t Temp_R1;
    uint8_t Temp_R2;
    uint8_t Temp_R3;
    uint8_t Temp_R4;
} INT_coolant_temp_TypeDef;

#ifdef Tx_INT_coolant_temp
void Tx_INT_coolant_temp_Data(CAN_HandleTypeDef* hcan, INT_coolant_temp_TypeDef* INT_coolant_temp_Data);
#endif

//#define Tx_INT_coolant_temp_left_raw 1
#define Rx_INT_coolant_temp_left_raw 1
#define ID_INT_coolant_temp_left_raw 0x256
#define DLC_INT_coolant_temp_left_raw 6
/* INT_coolant_temp_left_raw
 * 
 *
 * ID 0x256
 * Message size DLC: 6 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * Temp_L1_raw      | A |  0 | 12 | uint16_t | 
 * Temp_L2_raw      | B | 12 | 12 | uint16_t | 
 * Temp_L3_raw      | C | 24 | 12 | uint16_t | 
 * Temp_L4_raw      | D | 36 | 12 | uint16_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|B|B|B|B|
// b |2|B|B|B|B|B|B|B|B|
// y |3|C|C|C|C|C|C|C|C|
// t |4|C|C|C|C|D|D|D|D|
// e |5|D|D|D|D|D|D|D|D|
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint16_t Temp_L1_raw;
    uint16_t Temp_L2_raw;
    uint16_t Temp_L3_raw;
    uint16_t Temp_L4_raw;
} INT_coolant_temp_left_raw_TypeDef;

#ifdef Tx_INT_coolant_temp_left_raw
void Tx_INT_coolant_temp_left_raw_Data(CAN_HandleTypeDef* hcan, INT_coolant_temp_left_raw_TypeDef* INT_coolant_temp_left_raw_Data);
#endif

//#define Tx_INT_coolant_temp_right_raw 1
#define Rx_INT_coolant_temp_right_raw 1
#define ID_INT_coolant_temp_right_raw 0x257
#define DLC_INT_coolant_temp_right_raw 6
/* INT_coolant_temp_right_raw
 * 
 *
 * ID 0x257
 * Message size DLC: 6 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * Temp_R1_raw      | A |  0 | 12 | uint16_t | 
 * Temp_R2_raw      | B | 12 | 12 | uint16_t | 
 * Temp_R3_raw      | C | 24 | 12 | uint16_t | 
 * Temp_R4_raw      | D | 36 | 12 | uint16_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|B|B|B|B|
// b |2|B|B|B|B|B|B|B|B|
// y |3|C|C|C|C|C|C|C|C|
// t |4|C|C|C|C|D|D|D|D|
// e |5|D|D|D|D|D|D|D|D|
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint16_t Temp_R1_raw;
    uint16_t Temp_R2_raw;
    uint16_t Temp_R3_raw;
    uint16_t Temp_R4_raw;
} INT_coolant_temp_right_raw_TypeDef;

#ifdef Tx_INT_coolant_temp_right_raw
void Tx_INT_coolant_temp_right_raw_Data(CAN_HandleTypeDef* hcan, INT_coolant_temp_right_raw_TypeDef* INT_coolant_temp_right_raw_Data);
#endif

#define Tx_MCU_IMU_angular_velocity 1
#define Rx_MCU_IMU_angular_velocity 1
#define ID_MCU_IMU_angular_velocity 0x260
#define DLC_MCU_IMU_angular_velocity 7
/* MCU_IMU_angular_velocity
 * 60/64 bits
 *
 * ID 0x260
 * Message size DLC: 7 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * gyrX             | A |  0 | 20 |  int32_t | 
 * gyrY             | B | 20 | 20 |  int32_t | 
 * gyrZ             | C | 40 | 20 |  int32_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2|A|A|A|A|B|B|B|B|
// y |3|B|B|B|B|B|B|B|B|
// t |4|B|B|B|B|B|B|B|B|
// e |5|C|C|C|C|C|C|C|C|
//   |6|C|C|C|C|C|C|C|C|
//   |7|C|C|C|C| | | | |
typedef struct
{
    int32_t gyrX;
    int32_t gyrY;
    int32_t gyrZ;
} MCU_IMU_angular_velocity_TypeDef;

#ifdef Tx_MCU_IMU_angular_velocity
void Tx_MCU_IMU_angular_velocity_Data(CAN_HandleTypeDef* hcan, MCU_IMU_angular_velocity_TypeDef* MCU_IMU_angular_velocity_Data);
#endif

#define Tx_MCU_IMU_acceleration 1
#define Rx_MCU_IMU_acceleration 1
#define ID_MCU_IMU_acceleration 0x270
#define DLC_MCU_IMU_acceleration 7
/* MCU_IMU_acceleration
 * 
 *
 * ID 0x270
 * Message size DLC: 7 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * accX             | A |  0 | 20 |  int32_t | 
 * accY             | B | 20 | 20 |  int32_t | 
 * accZ             | C | 40 | 20 |  int32_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2|A|A|A|A|B|B|B|B|
// y |3|B|B|B|B|B|B|B|B|
// t |4|B|B|B|B|B|B|B|B|
// e |5|C|C|C|C|C|C|C|C|
//   |6|C|C|C|C|C|C|C|C|
//   |7|C|C|C|C| | | | |
typedef struct
{
    int32_t accX;
    int32_t accY;
    int32_t accZ;
} MCU_IMU_acceleration_TypeDef;

#ifdef Tx_MCU_IMU_acceleration
void Tx_MCU_IMU_acceleration_Data(CAN_HandleTypeDef* hcan, MCU_IMU_acceleration_TypeDef* MCU_IMU_acceleration_Data);
#endif

#define Tx_MCU_IMU_euler_angles 1
#define Rx_MCU_IMU_euler_angles 1
#define ID_MCU_IMU_euler_angles 0x280
#define DLC_MCU_IMU_euler_angles 7
/* MCU_IMU_euler_angles
 * 
 *
 * ID 0x280
 * Message size DLC: 7 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * roll             | A |  0 | 20 |  int32_t | 
 * pitch            | B | 20 | 20 |  int32_t | 
 * yaw              | C | 40 | 20 |  int32_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2|A|A|A|A|B|B|B|B|
// y |3|B|B|B|B|B|B|B|B|
// t |4|B|B|B|B|B|B|B|B|
// e |5|C|C|C|C|C|C|C|C|
//   |6|C|C|C|C|C|C|C|C|
//   |7|C|C|C|C| | | | |
typedef struct
{
    int32_t roll;
    int32_t pitch;
    int32_t yaw;
} MCU_IMU_euler_angles_TypeDef;

#ifdef Tx_MCU_IMU_euler_angles
void Tx_MCU_IMU_euler_angles_Data(CAN_HandleTypeDef* hcan, MCU_IMU_euler_angles_TypeDef* MCU_IMU_euler_angles_Data);
#endif

#define Tx_MCU_IMU_gps_position 1
#define Rx_MCU_IMU_gps_position 1
#define ID_MCU_IMU_gps_position 0x300
#define DLC_MCU_IMU_gps_position 8
/* MCU_IMU_gps_position
 * 
 *
 * ID 0x300
 * Message size DLC: 8 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * lat              | A |  0 | 32 | uint32_t | 
 * longitude        | B | 32 | 32 | uint32_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2|A|A|A|A|A|A|A|A|
// y |3|A|A|A|A|A|A|A|A|
// t |4|B|B|B|B|B|B|B|B|
// e |5|B|B|B|B|B|B|B|B|
//   |6|B|B|B|B|B|B|B|B|
//   |7|B|B|B|B|B|B|B|B|
typedef struct
{
    uint32_t lat;
    uint32_t longitude;
} MCU_IMU_gps_position_TypeDef;

#ifdef Tx_MCU_IMU_gps_position
void Tx_MCU_IMU_gps_position_Data(CAN_HandleTypeDef* hcan, MCU_IMU_gps_position_TypeDef* MCU_IMU_gps_position_Data);
#endif

#define Tx_MCU_IMU_gps_speed 1
#define Rx_MCU_IMU_gps_speed 1
#define ID_MCU_IMU_gps_speed 0x305
#define DLC_MCU_IMU_gps_speed 2
/* MCU_IMU_gps_speed
 * 
 *
 * ID 0x305
 * Message size DLC: 2 bytes
 * Message is sent by node: 
 * Message contains:
 *                   rep start len type        comment
 * gps_velocity     | A |  0 | 16 | uint16_t | 
 */

//             bit
//     |7|6|5|4|3|2|1|0|
//   |0|A|A|A|A|A|A|A|A|
//   |1|A|A|A|A|A|A|A|A|
// b |2| | | | | | | | |
// y |3| | | | | | | | |
// t |4| | | | | | | | |
// e |5| | | | | | | | |
//   |6| | | | | | | | |
//   |7| | | | | | | | |
typedef struct
{
    uint16_t gps_velocity;
} MCU_IMU_gps_speed_TypeDef;

#ifdef Tx_MCU_IMU_gps_speed
void Tx_MCU_IMU_gps_speed_Data(CAN_HandleTypeDef* hcan, MCU_IMU_gps_speed_TypeDef* MCU_IMU_gps_speed_Data);
#endif

struct CAN_Msg_Count
{
	uint32_t MID_020;
	uint32_t MID_060;
	uint32_t MID_070;
	uint32_t MID_090;
	uint32_t MID_100;
	uint32_t MID_120;
	uint32_t MID_130;
	uint32_t MID_200;
	uint32_t MID_220;
	uint32_t MID_225;
	uint32_t MID_230;
	uint32_t MID_250;
	uint32_t MID_255;
	uint32_t MID_256;
	uint32_t MID_257;
	uint32_t MID_260;
	uint32_t MID_270;
	uint32_t MID_280;
	uint32_t MID_300;
	uint32_t MID_305;
};

void reset_CAN_msgs_counter(void);

#endif /* CAN2020_H_s */
